"use client";

import { useMemo, useState } from "react";
import styles from "./AssistantRail.module.css";

type Suggestion = {
  id: string;
  text: string;
  citations: Array<{ title: string; href: string }>;
};

const seededSuggestions: Suggestion[] = [
  {
    id: "cta",
    text: "Reduce competing CTAs: keep one primary action, demote the rest to secondary to sharpen hierarchy.",
    citations: [
      { title: "Design System: CTA hierarchy", href: "#" },
      { title: "UX principle: one primary per view", href: "#" },
    ],
  },
  {
    id: "motion",
    text: "Use motion only as feedback (hover, state changes, subtle reveal). Respect reduced-motion automatically.",
    citations: [
      { title: "Motion guidelines", href: "#" },
      { title: "Reduced motion support", href: "#" },
    ],
  },
];

export function AssistantRail() {
  const [prompt, setPrompt] = useState("Summarize how to improve this page’s hierarchy.");
  const [isGenerating, setIsGenerating] = useState(false);
  const [active, setActive] = useState<Suggestion | null>(seededSuggestions[0]);
  const [appliedIds, setAppliedIds] = useState<string[]>([]);
  const [lastAppliedId, setLastAppliedId] = useState<string | null>(null);
  const [showWhy, setShowWhy] = useState(false);

  const appliedSet = useMemo(() => new Set(appliedIds), [appliedIds]);

  function run() {
    setIsGenerating(true);
    window.setTimeout(() => {
      const promptLower = prompt.toLowerCase();
      const keywordMatch =
        promptLower.includes("motion") || promptLower.includes("animation")
          ? "motion"
          : promptLower.includes("cta") || promptLower.includes("button")
            ? "cta"
            : null;

      const next =
        (keywordMatch ? seededSuggestions.find((s) => s.id === keywordMatch) : null) ??
        (() => {
          const currentIndex = seededSuggestions.findIndex((s) => s.id === (active?.id ?? seededSuggestions[0].id));
          const nextIndex = (currentIndex + 1) % seededSuggestions.length;
          return seededSuggestions[nextIndex];
        })();
      setActive(next);
      setShowWhy(false);
      setIsGenerating(false);
    }, 700);
  }

  function apply() {
    if (!active || appliedSet.has(active.id)) return;
    setAppliedIds((prev) => [...prev, active.id]);
    setLastAppliedId(active.id);
  }

  function undo() {
    if (!lastAppliedId) return;
    setAppliedIds((prev) => prev.filter((id) => id !== lastAppliedId));
    setLastAppliedId(null);
  }

  function resetApplied() {
    if (!appliedIds.length) return;
    const ok = window.confirm("Clear applied items? This is just a demo of confirmation UI.");
    if (!ok) return;
    setAppliedIds([]);
    setLastAppliedId(null);
  }

  return (
    <section className={styles.panel} aria-label="AI Assistant">
      <div className={styles.header}>
        <h2 className={styles.title}>Assistant Rail</h2>
        <div className={styles.disclosure}>
          <span className={styles.badge} title="This content is generated by AI. Review before applying.">
            AI-generated
          </span>
        </div>
      </div>

      <p className={styles.hint}>
        Human-in-control: you can apply or undo changes. This is a starter UI pattern, not a full chatbot.
      </p>

      <div className={styles.promptRow}>
        <input
          className={styles.input}
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Ask for a UI change…"
          aria-label="Prompt"
        />
        <button className={`${styles.btn} ${styles.btnPrimary}`} type="button" onClick={run}>
          Ask
        </button>
      </div>

      <div className={styles.output} aria-live="polite">
        {isGenerating ? (
          <div className={styles.typing} aria-label="Generating">
            <span>Thinking</span>
            <span className={styles.dot} />
            <span className={styles.dot} />
            <span className={styles.dot} />
          </div>
        ) : (
          <>
            <p className={styles.text}>{active?.text}</p>
            <div className={styles.citations} aria-label="Citations">
              {(active?.citations ?? []).map((c, idx) => (
                <span key={c.title} className={styles.chip} title={c.title}>
                  <span className={styles.chipNumber}>{idx + 1}</span>
                  <a href={c.href}>{c.title}</a>
                </span>
              ))}
            </div>
            <div className={styles.whyRow}>
              <button className={styles.btn} type="button" onClick={() => setShowWhy((v) => !v)}>
                Why this?
              </button>
            </div>
            {showWhy ? (
              <p className={styles.hint}>
                This suggestion targets high-leverage UX: clearer hierarchy reduces cognitive load and makes the
                primary action obvious. It also reduces regret by keeping changes easy to apply/undo.
              </p>
            ) : null}
          </>
        )}
      </div>

      <div className={styles.controls}>
        <div className={styles.controlRow}>
          <button className={styles.btn} type="button" onClick={apply} disabled={!active || appliedSet.has(active.id)}>
            Apply
          </button>
          <button className={styles.btn} type="button" onClick={undo} disabled={!lastAppliedId}>
            Undo
          </button>
          <button className={styles.btn} type="button" onClick={resetApplied} disabled={!appliedIds.length}>
            Reset
          </button>
        </div>

        <div className={styles.status} aria-live="polite">
          Applied:{" "}
          <span className={appliedIds.length ? styles.statusStrong : undefined}>{appliedIds.length}</span>
        </div>
      </div>
    </section>
  );
}
